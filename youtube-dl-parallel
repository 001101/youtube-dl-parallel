#!/bin/bash
# Copyright (c) 2013 DLH. See LICENSE.txt for the MIT license.

function error() {
    echo "Error: $@"
    echo
    echo "Traceback"
    echo "========="
    local frame=0
    while caller $frame; do
        ((frame++));
    done
    exit 1
}

function prettify_output() {
    local output_file=$1
    local padding=$2
    local prefix=$3
    while read line; do
        local computed_prefix=$(printf "%-${padding}s:" "$prefix")
        # Keep only the latest "[download]" line
        awk -v prefix="$computed_prefix [download]" \
            'index($0, prefix) { found_line = 1 } { if (!found_line) print $0 }' \
            "$output_file" > "$output_file.tmp"
        mv "$output_file.tmp" "$output_file"
        echo "$computed_prefix $line" >> "$output_file"
    done
}

function download() {
    local output_directory=$1
    local padding=$2
    local prefix=$3
    local url=$4
    shift 4
    local output_file="$output_directory/$PARALLEL_SEQ"
    touch "$output_file"
    youtube-dl "$@" --no-playlist --newline -- "$url" 2>&1 | prettify_output "$output_file" "$padding" "$prefix"
}

function get_title() {
    local title_directory=$1
    local url=$2
    local title=$(youtube-dl --no-playlist --youtube-skip-dash-manifest --get-title -- "$url" 2>&1)
    test $? -eq 0 || title="$url"
    echo "$title" > "$title_directory/$PARALLEL_SEQ"
}

function parse_options()  {
    while getopts "hj:" option "$@"; do
        case $option in
            h)
                echo "Usage: ${0##*/} [-hj] <url> [<url> ...] [-- <youtube-dl options>]"
                echo "    -h       : Shows this help message."
                echo "    -j <jobs>: The number of jobs to run in parallel. The default is 3."
                echo
                echo "If “-” is provided as an argument, then urls will additionally be read from stdin."
                exit;;
            j)
                JOBS="$OPTARG";;
            \?)
                error "Unknown option";;
        esac
    done

    # Special case. See test/test_options_ytdl_args_no_urls.sh
    if test $# -gt 0 -a "$1" != "--"; then
        shift $((OPTIND - 1))
    fi

    for url in "$@"; do
        if test "$url" = "-"; then
            while read line; do
                URLS+=($line)
            done
        elif test "$url" = "--"; then
            shift
            YOUTUBE_DL_ARGS="$@"
            break
        else
            URLS+=($url)
        fi
        shift
    done
}

function find_longest_title() {
    local title_directory=$1
    for f in $(ls "$title_directory" | sort -n); do
        local title=$(cat "$title_directory/$f")
        local length=$(echo -n "$title" | wc -m | tr -d '[[:space:]]')
        if test $length -gt $TITLE_PADDING; then
            TITLE_PADDING=$length
        fi
        URL_TITLES+=("$title")
    done
}

function create_temp_directory() {
    mktemp -d -t youtube-dl-parallel.XXX || error "mktemp failed"
}

function parallel_will_cite_option() {
    parallel --gnu --will-cite true ::: "" > /dev/null 2>&1 && echo "--will-cite"
    return 0
}

function is_tty() {
    test -t 1
}

function display_output() {
    local output_directory=$1
    if is_tty; then
        tput rc
        tput ed
    fi
    for f in $(ls "$output_directory" | grep -v "\.tmp$" | sort -n); do
        cat "$output_directory/$f"
    done
}

function display_output_periodically() {
    local output_directory=$1
    if is_tty; then
        tput sc
        trap "tput clear && tput sc" SIGWINCH
    fi
    while true; do
        display_output "$output_directory"
        sleep 1
    done
}

function main() {
    parse_options "$@"
    if test -z "$URLS"; then
        error "No urls specified. Try ${0##*/} -h for more information."
    fi

    local temp_directory=$(create_temp_directory)
    trap "rm -r '$temp_directory'" EXIT
    local title_directory="$temp_directory/titles"
    local output_directory="$temp_directory/outputs"
    mkdir "$title_directory" "$output_directory"

    # Export functions for use with parallel
    export -f prettify_output download get_title

    # * Check if we can use the --will-cite option. Ubuntu 12.04 LTS ships with a very
    #   old version of GNU Parallel that does not support it
    # * Ubuntu 12.04's parallel also uses the --tollef option by default, so we need
    #   to override that here.
    # * We use --will-cite because the end-user should not be spammed to cite our usage
    #   of GNU Parallel.
    local args="$(parallel_will_cite_option) --gnu --jobs $JOBS"

    parallel $args "get_title '$title_directory'" ::: "${URLS[@]}"
    find_longest_title "$title_directory"

    display_output_periodically "$output_directory" &
    trap "kill $!" EXIT

    parallel $args --xapply --ungroup "download '$output_directory' $((TITLE_PADDING + 1)) {1} {2} $YOUTUBE_DL_ARGS" ::: "${URL_TITLES[@]}" ::: "${URLS[@]}"
    display_output "$output_directory"
}

# Global variables
declare -a URLS URL_TITLES
JOBS=3
YOUTUBE_DL_ARGS=
TITLE_PADDING=0

if test "${BASH_SOURCE[0]}" = "${0}"; then
    main "$@"
fi
